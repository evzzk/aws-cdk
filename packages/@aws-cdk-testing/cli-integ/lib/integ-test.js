"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.integTest = integTest;
exports.randomString = randomString;
const fs = require("fs");
const path = require("path");
const corking_1 = require("./corking");
const SKIP_TESTS = fs.readFileSync(path.join(__dirname, '..', 'skip-tests.txt'), { encoding: 'utf-8' })
    .split('\n')
    .map(x => x.trim())
    .filter(x => x && !x.startsWith('#'));
if (SKIP_TESTS) {
    process.stderr.write(`ℹ️ Skipping tests: ${JSON.stringify(SKIP_TESTS)}\n`);
}
;
if (process.env.JEST_TEST_CONCURRENT === 'true') {
    process.stderr.write('ℹ️ JEST_TEST_CONCURRENT is true: tests will run concurrently and filters have no effect!\n0');
}
/**
 * A wrapper for jest's 'test' which takes regression-disabled tests into account and prints a banner
 */
function integTest(name, callback, timeoutMillis) {
    // Integ tests can run concurrently, and are responsible for blocking
    // themselves if they cannot.  Because `test.concurrent` executes the test
    // code immediately, regardles of any `--testNamePattern`, this cannot be the
    // default: test filtering simply does not work with `test.concurrent`.
    // Instead, we make it opt-in only for the pipeline where we don't do any
    // selection, but execute all tests unconditionally.
    const testKind = process.env.JEST_TEST_CONCURRENT === 'true' ? test.concurrent : test;
    const runner = shouldSkip(name) ? testKind.skip : testKind;
    runner(name, async () => {
        const output = new corking_1.MemoryStream();
        output.write('================================================================\n');
        output.write(`${name}\n`);
        output.write('================================================================\n');
        const now = Date.now();
        process.stderr.write(`[INTEG TEST::${name}] Starting (pid ${process.pid})...\n`);
        try {
            return await callback({
                output,
                randomString: randomString(),
                log(s) {
                    output.write(`${s}\n`);
                },
            });
        }
        catch (e) {
            process.stderr.write(`[INTEG TEST::${name}] Failed: ${e}\n`);
            output.write(e.message);
            output.write(e.stack);
            // Print output only if the test fails. Use 'console.log' so the output is buffered by
            // jest and prints without a stack trace (if verbose: false).
            // eslint-disable-next-line no-console
            console.log(output.buffer().toString());
            throw e;
        }
        finally {
            const duration = Date.now() - now;
            process.stderr.write(`[INTEG TEST::${name}] Done (${duration} ms).\n`);
        }
    }, timeoutMillis);
}
function shouldSkip(testName) {
    return SKIP_TESTS.includes(testName);
}
function randomString() {
    // Crazy
    return Math.random().toString(36).replace(/[^a-z0-9]+/g, '');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZWctdGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImludGVnLXRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUEwQkEsOEJBNkNDO0FBTUQsb0NBR0M7QUFoRkQseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3Qix1Q0FBeUM7QUFFekMsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQztLQUNwRyxLQUFLLENBQUMsSUFBSSxDQUFDO0tBQ1gsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0tBQ2xCLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUV4QyxJQUFJLFVBQVUsRUFBRSxDQUFDO0lBQ2YsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsc0JBQXNCLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdFLENBQUM7QUFNQSxDQUFDO0FBRUYsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixLQUFLLE1BQU0sRUFBRSxDQUFDO0lBQ2hELE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLDZGQUE2RixDQUFDLENBQUM7QUFDdEgsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsU0FBUyxDQUN2QixJQUFZLEVBQ1osUUFBaUQsRUFDakQsYUFBc0I7SUFFdEIscUVBQXFFO0lBQ3JFLDBFQUEwRTtJQUMxRSw2RUFBNkU7SUFDN0UsdUVBQXVFO0lBQ3ZFLHlFQUF5RTtJQUN6RSxvREFBb0Q7SUFDcEQsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUN0RixNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztJQUUzRCxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ3RCLE1BQU0sTUFBTSxHQUFHLElBQUksc0JBQVksRUFBRSxDQUFDO1FBRWxDLE1BQU0sQ0FBQyxLQUFLLENBQUMsb0VBQW9FLENBQUMsQ0FBQztRQUNuRixNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQztRQUMxQixNQUFNLENBQUMsS0FBSyxDQUFDLG9FQUFvRSxDQUFDLENBQUM7UUFFbkYsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixJQUFJLG1CQUFtQixPQUFPLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztRQUNqRixJQUFJLENBQUM7WUFDSCxPQUFPLE1BQU0sUUFBUSxDQUFDO2dCQUNwQixNQUFNO2dCQUNOLFlBQVksRUFBRSxZQUFZLEVBQUU7Z0JBQzVCLEdBQUcsQ0FBQyxDQUFTO29CQUNYLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN6QixDQUFDO2FBQ0YsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUFDLE9BQU8sQ0FBTSxFQUFFLENBQUM7WUFDaEIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzdELE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3hCLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RCLHNGQUFzRjtZQUN0Riw2REFBNkQ7WUFDN0Qsc0NBQXNDO1lBQ3RDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDeEMsTUFBTSxDQUFDLENBQUM7UUFDVixDQUFDO2dCQUFTLENBQUM7WUFDVCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDO1lBQ2xDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixJQUFJLFdBQVcsUUFBUSxTQUFTLENBQUMsQ0FBQztRQUN6RSxDQUFDO0lBQ0gsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBQ3BCLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxRQUFnQjtJQUNsQyxPQUFPLFVBQVUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDdkMsQ0FBQztBQUVELFNBQWdCLFlBQVk7SUFDMUIsUUFBUTtJQUNSLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQy9ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgTWVtb3J5U3RyZWFtIH0gZnJvbSAnLi9jb3JraW5nJztcblxuY29uc3QgU0tJUF9URVNUUyA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnc2tpcC10ZXN0cy50eHQnKSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KVxuICAuc3BsaXQoJ1xcbicpXG4gIC5tYXAoeCA9PiB4LnRyaW0oKSlcbiAgLmZpbHRlcih4ID0+IHggJiYgIXguc3RhcnRzV2l0aCgnIycpKTtcblxuaWYgKFNLSVBfVEVTVFMpIHtcbiAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoYOKEue+4jyBTa2lwcGluZyB0ZXN0czogJHtKU09OLnN0cmluZ2lmeShTS0lQX1RFU1RTKX1cXG5gKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXN0Q29udGV4dCB7XG4gIHJlYWRvbmx5IHJhbmRvbVN0cmluZzogc3RyaW5nO1xuICByZWFkb25seSBvdXRwdXQ6IE5vZGVKUy5Xcml0YWJsZVN0cmVhbTtcbiAgbG9nKHM6IHN0cmluZyk6IHZvaWQ7XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuSkVTVF9URVNUX0NPTkNVUlJFTlQgPT09ICd0cnVlJykge1xuICBwcm9jZXNzLnN0ZGVyci53cml0ZSgn4oS577iPIEpFU1RfVEVTVF9DT05DVVJSRU5UIGlzIHRydWU6IHRlc3RzIHdpbGwgcnVuIGNvbmN1cnJlbnRseSBhbmQgZmlsdGVycyBoYXZlIG5vIGVmZmVjdCFcXG4wJyk7XG59XG5cbi8qKlxuICogQSB3cmFwcGVyIGZvciBqZXN0J3MgJ3Rlc3QnIHdoaWNoIHRha2VzIHJlZ3Jlc3Npb24tZGlzYWJsZWQgdGVzdHMgaW50byBhY2NvdW50IGFuZCBwcmludHMgYSBiYW5uZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVnVGVzdChcbiAgbmFtZTogc3RyaW5nLFxuICBjYWxsYmFjazogKGNvbnRleHQ6IFRlc3RDb250ZXh0KSA9PiBQcm9taXNlPHZvaWQ+LFxuICB0aW1lb3V0TWlsbGlzPzogbnVtYmVyLFxuKTogdm9pZCB7XG4gIC8vIEludGVnIHRlc3RzIGNhbiBydW4gY29uY3VycmVudGx5LCBhbmQgYXJlIHJlc3BvbnNpYmxlIGZvciBibG9ja2luZ1xuICAvLyB0aGVtc2VsdmVzIGlmIHRoZXkgY2Fubm90LiAgQmVjYXVzZSBgdGVzdC5jb25jdXJyZW50YCBleGVjdXRlcyB0aGUgdGVzdFxuICAvLyBjb2RlIGltbWVkaWF0ZWx5LCByZWdhcmRsZXMgb2YgYW55IGAtLXRlc3ROYW1lUGF0dGVybmAsIHRoaXMgY2Fubm90IGJlIHRoZVxuICAvLyBkZWZhdWx0OiB0ZXN0IGZpbHRlcmluZyBzaW1wbHkgZG9lcyBub3Qgd29yayB3aXRoIGB0ZXN0LmNvbmN1cnJlbnRgLlxuICAvLyBJbnN0ZWFkLCB3ZSBtYWtlIGl0IG9wdC1pbiBvbmx5IGZvciB0aGUgcGlwZWxpbmUgd2hlcmUgd2UgZG9uJ3QgZG8gYW55XG4gIC8vIHNlbGVjdGlvbiwgYnV0IGV4ZWN1dGUgYWxsIHRlc3RzIHVuY29uZGl0aW9uYWxseS5cbiAgY29uc3QgdGVzdEtpbmQgPSBwcm9jZXNzLmVudi5KRVNUX1RFU1RfQ09OQ1VSUkVOVCA9PT0gJ3RydWUnID8gdGVzdC5jb25jdXJyZW50IDogdGVzdDtcbiAgY29uc3QgcnVubmVyID0gc2hvdWxkU2tpcChuYW1lKSA/IHRlc3RLaW5kLnNraXAgOiB0ZXN0S2luZDtcblxuICBydW5uZXIobmFtZSwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBNZW1vcnlTdHJlYW0oKTtcblxuICAgIG91dHB1dC53cml0ZSgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbicpO1xuICAgIG91dHB1dC53cml0ZShgJHtuYW1lfVxcbmApO1xuICAgIG91dHB1dC53cml0ZSgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbicpO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShgW0lOVEVHIFRFU1Q6OiR7bmFtZX1dIFN0YXJ0aW5nIChwaWQgJHtwcm9jZXNzLnBpZH0pLi4uXFxuYCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcmFuZG9tU3RyaW5nOiByYW5kb21TdHJpbmcoKSxcbiAgICAgICAgbG9nKHM6IHN0cmluZykge1xuICAgICAgICAgIG91dHB1dC53cml0ZShgJHtzfVxcbmApO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShgW0lOVEVHIFRFU1Q6OiR7bmFtZX1dIEZhaWxlZDogJHtlfVxcbmApO1xuICAgICAgb3V0cHV0LndyaXRlKGUubWVzc2FnZSk7XG4gICAgICBvdXRwdXQud3JpdGUoZS5zdGFjayk7XG4gICAgICAvLyBQcmludCBvdXRwdXQgb25seSBpZiB0aGUgdGVzdCBmYWlscy4gVXNlICdjb25zb2xlLmxvZycgc28gdGhlIG91dHB1dCBpcyBidWZmZXJlZCBieVxuICAgICAgLy8gamVzdCBhbmQgcHJpbnRzIHdpdGhvdXQgYSBzdGFjayB0cmFjZSAoaWYgdmVyYm9zZTogZmFsc2UpLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKG91dHB1dC5idWZmZXIoKS50b1N0cmluZygpKTtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGBbSU5URUcgVEVTVDo6JHtuYW1lfV0gRG9uZSAoJHtkdXJhdGlvbn0gbXMpLlxcbmApO1xuICAgIH1cbiAgfSwgdGltZW91dE1pbGxpcyk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFNraXAodGVzdE5hbWU6IHN0cmluZykge1xuICByZXR1cm4gU0tJUF9URVNUUy5pbmNsdWRlcyh0ZXN0TmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gIC8vIENyYXp5XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5yZXBsYWNlKC9bXmEtejAtOV0rL2csICcnKTtcbn1cbiJdfQ==